#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# User creation code
# See also synapse/rest/client/v1/watcha.py
#
#

from os.path import dirname, join
from email.mime.text import MIMEText

from matrix_client.client import MatrixClient

from synapse.handlers.invite_external import generate_password

# TODO: send password via SMS ("Votre mot de passe vous a été envoyé par SMS au numéro: ")

CONFIRMATION_EMAIL_SUBJECT_FR = u'''Accès à l'espace de travail sécurisé {instance} Watcha'''
CONFIRMATION_EMAIL_MESSAGE_FR = u'''Bonjour {full_name},



{requester_name} vous a invité à participer à l’espace de travail sécurisé {instance} Watcha.
Pour y accéder, votre nom d’utilisateur est :

{user_login}

et votre mot de passe est:

{user_password}




Vous pouvez accéder à l’espace de travail à partir d’un navigateur sur {server}.
Vous pouvez installer aussi un client mobile :

pour Android: https://play.google.com/store/apps/details?id=im.watcha
Pour iOS: https://itunes.apple.com/us/app/riot-im/id1083446067

Sur l'application mobile, choisissez "Utiliser un serveur personnalisé" et entrez les valeurs:

Serveur d'accueil : {server}
Serveur d'identité : {server}

{help_info}

Vous pouvez aussi à répondre à cet email si vous avez des difficultés à utiliser Watcha,

Cordialement,

L'équipe Watcha.
'''


HELP_INFO_REFERENT=u'''Vous êtes le référent pour cette installation de la solution Watcha : vous avez été identifié au sens de votre organisation comme la personne à contacter pour toute question relative à l'utilisation de la solution.'''
HELP_INFO_OTHER=u'''N’hésitez pas à contacter votre référent, {referent_name}, {referent_email}, si question.'''

EMAIL_SETTINGS = {
    'smtphost': 'mail.infomaniak.com',
    'from_addr': 'Watcha registration <registration@watcha.fr>',
    'port': 587,
    'username': "registration@watcha.fr",
    'password': u"Fyr-Www-9t9-V8M",
    'requireAuthentication': True,
    'requireTransportSecurity': True,
}

def _send_registration_email(requester_name, full_name, user_email, user_login, user_password,
                              referent_name, referent_email, admin,
                              instance, server):

    if admin:
        help_info = HELP_INFO_REFERENT
    else:
        help_info = HELP_INFO_OTHER.format(**{'referent_name': referent_name, 'referent_email': referent_email })

    message = CONFIRMATION_EMAIL_MESSAGE_FR.format(**{
        'full_name': full_name,
        'instance': instance,
        'server': server,
        'user_login': user_login,
        'user_password': user_password,
        'requester_name': requester_name,
        'help_info': help_info,
        })
    subject = CONFIRMATION_EMAIL_SUBJECT_FR.format(**{
        'instance': instance
    })

    msg = MIMEText(message, "plain", "utf8")
    msg['Subject'] = subject
    msg['From'] = EMAIL_SETTINGS['from_addr']
    msg['To'] = user_email

    if False: # not EMAIL_SETTINGS['requireTransportSecurity']: # TODO: not working ?
        from smtplib import SMTP_SSL as SMTP       # this invokes the secure SMTP protocol (port 465, uses SSL)
    else:
        from smtplib import SMTP                  # use this for standard SMTP protocol   (port 25, no encryption)


    conn = SMTP(EMAIL_SETTINGS['smtphost'], port=EMAIL_SETTINGS['port'])
    # TODO 'port': 587,
    conn.set_debuglevel(False)
    conn.login(EMAIL_SETTINGS['username'], EMAIL_SETTINGS['password'])
    try:
        conn.sendmail(EMAIL_SETTINGS['from_addr'], [user_email], msg.as_string())
        print("Registration mail sent to %s" % user_email )
    except Exception, exc:
        print("Registration mail failed: %s" % str(exc) )
    finally:
        conn.quit()

def later():
    params = {
        'src' : '1111111111', # Sender's phone number with country code
        'dst' : user_phone, # Receiver's phone Number with country code
        'text' : u"Le mdp watcha est: " + new_pass, # Your SMS Text Message - French
        #    'url' : "http://example.com/report/", # The URL to which with the status of the message is sent
        'method' : 'POST' # The method used to call the url
    }

    # FIXME comment for now to avoid to waste SMS fees
    response = self.sms.send_message(params)
    # FIXME handle error:
    #if response[0] != 202:

    # FIXME allow to send again mail/SMS...
    # Success


VERSION = "0.5"
CONFIG_TEMPLATE=u'''# -*- coding: utf-8 -*-

# Version of this file, do not modify
VERSION = "{version}"


SERVER = "https://url.to.the.server"
CORE = "https://url.to.the.core.server"

# Name of the person or institution who sends the email
ADMIN=""

# The name of the Watcha instance. Usually the customer's name (e.g. company name)
INSTANCE=""

USERS = [
    # [u'full name', 'email adress', 'user name']
]

REFERENT_USERNAME='a user name in USERS'
'''.format(version=VERSION)

def main():
    from os.path import basename, dirname, exists, splitext, abspath
    import sys

    if len(sys.argv) < 2:
        print 'Usage: register_watcha_users <user configuration file>.py'
        return
    config_file = abspath(sys.argv[1])
    if not config_file.endswith('.py'):
        print "Config file name must finish with .py"
        return

    if not exists(config_file):
        with open(config_file, 'w') as f:
            f.write(CONFIG_TEMPLATE)
        print "Template user configuration file created at %s. Please fill it now and re-run" % config_file
        return

    # the loading of the register_new_matrix_user file, and of the config file, are **ugly**... but I don't find easier ways...
    mylocals = {}
    execfile(join(dirname(__file__), 'register_new_matrix_user'), {'__name__': None}, mylocals)
    mylocals['__name__'] = None
    execfile(join(dirname(__file__), 'register_new_matrix_user'), mylocals, mylocals)
    register_new_user = mylocals['register_new_user']

    sys.path.append(dirname(config_file))
    try:
        config = __import__(splitext(basename(config_file))[0], ['USERS', 'SERVER', 'CORE', 'ADMIN', 'INSTANCE',
                                                                 'SHARED_SECRET', 'REFERENT_USERNAME', 'VERSION'])
    except ImportError, e:
        print "Could not import users from file %s. Is it a valid file ?" % config_file
        return

    if not hasattr(config, 'VERSION') or config.VERSION != VERSION:
        print "Config file version ({config_version}) incompatible with this version ({script_version}) of the script. Maybe pull an older version of the script ?".format(config_version=(config.VERSION if hasattr(config, 'VERSION') else 'none found'), script_version=VERSION)
        return

    if not config.USERS:
        print "No user found in %s, please edit file and add users" % config_file
        return
    if not config.SHARED_SECRET:
        print "No shared secret in %s, please edit file and add users" % config_file
        return

    referents = [user for user in config.USERS if config.REFERENT_USERNAME == user[2]]
    if not referents:
        print "Referent user name not found in list of users"
        return

    referent = referents[0]
    referent_name, referent_email, _ = referent

    print "User creation commands to run on the server:"
    print
    for user in config.USERS:
        full_name, email, user_name = user
        password = generate_password()
        admin = config.REFERENT_USERNAME == user_name

        register_new_user(user_name, password, config.CORE, config.SHARED_SECRET, 'y' if admin else 'n')

        client = MatrixClient(config.CORE)
        token = client.login_with_password(username=user_name, password=password)
        user = client.get_user(client.user_id)
        user.set_display_name(full_name)
        print 'Display name:', user.get_display_name()

        _send_registration_email(config.ADMIN, full_name, email, user_name, password,
                                 referent_name, referent_email, admin,
                                 config.INSTANCE, config.SERVER)

if __name__ == "__main__":
    main()
