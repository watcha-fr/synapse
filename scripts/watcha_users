#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# User creation code
# See also synapse/rest/client/v1/watcha.py
#
#

from os.path import dirname, join
from email.mime.text import MIMEText
import hashlib
import hmac
import json
import sys
import urllib2

from synapse.types import get_localpart_from_id

from matrix_client.client import MatrixClient

# TODO: password generation, and email sending, should be done on the server,
# to avoid duplicate code, see synapse/handlers/invite_external.py,
# and for better security (the password should not be accessible to the admin client)
from synapse.handlers.invite_external import generate_password, EMAIL_SETTINGS

HELP = u'''


Vous pouvez accéder à l’espace de travail à partir d’un navigateur sur {server}.
Vous pouvez installer aussi un client mobile :

pour Android: https://play.google.com/store/apps/details?id=im.watcha
Pour iOS: https://itunes.apple.com/us/app/riot-im/id1083446067

Sur l'application mobile, choisissez "Utiliser un serveur personnalisé" et entrez les valeurs:

Serveur d'accueil : {server}
Serveur d'identité : {server}

{help_info}

Vous pouvez aussi à répondre à cet email si vous avez des difficultés à utiliser Watcha,

Cordialement,

L'équipe Watcha.
'''

CONFIRMATION_EMAIL_SUBJECT_FR = u'''Accès à l'espace de travail sécurisé {instance} Watcha'''
CONFIRMATION_EMAIL_MESSAGE_FR = u'''Bonjour {full_name},



{requester_name} vous a invité à participer à l’espace de travail sécurisé {instance} Watcha.
Pour y accéder, votre nom d’utilisateur est :

{user_login}

et votre mot de passe est :

{user_password}


''' + HELP

PASSWORD_EMAIL_SUBJECT_FR = u'''Nouveau mot de passe pour l'espace de travail sécurisé {instance} Watcha'''
PASSWORD_EMAIL_MESSAGE_FR = u'''Bonjour {full_name},



Votre mot de passe pour accéder à l’espace de travail sécurisé {instance} Watcha a été changé.

Votre nom d’utilisateur est toujours :

{user_login}

et votre mot de passe est maintenant :

{user_password}

''' + HELP


HELP_INFO_REFERENT=u'''Vous êtes le référent pour cette installation de la solution Watcha : vous avez été identifié au sens de votre organisation comme la personne à contacter pour toute question relative à l'utilisation de la solution.'''
HELP_INFO_OTHER=u'''N’hésitez pas à contacter votre référent, {referent_name}, {referent_email}, si question.'''

# Copied from `request_registration` in file `scripts/register_new_matrix_user`
def _request_registration(endpoint, user, password, server_location, shared_secret, admin=False):
    mac = hmac.new(
        key=shared_secret,
        digestmod=hashlib.sha1,
    )

    mac.update(user)
    mac.update("\x00")
    mac.update(password)
    mac.update("\x00")
    mac.update("admin" if admin else "notadmin")

    mac = mac.hexdigest()

    data = {
        "user": user,
        "password": password,
        "mac": mac,
        "type": "org.matrix.login.shared_secret",
        "admin": admin,
    }

    server_location = server_location.rstrip("/")

    print "Sending %s request..." % endpoint

    req = urllib2.Request(
        "%s/_matrix/client/api/v1/%s" % (server_location, endpoint),
        data=json.dumps(data),
        headers={'Content-Type': 'application/json'}
    )

    try:
        if sys.version_info[:3] >= (2, 7, 9):
            # As of version 2.7.9, urllib2 now checks SSL certs
            import ssl
            f = urllib2.urlopen(req, context=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
        else:
            f = urllib2.urlopen(req)
        f.read()
        f.close()
        print "Success."
    except urllib2.HTTPError as e:
        print "ERROR! Received %d %s" % (e.code, e.reason,)
        if 400 <= e.code < 500:
            if e.info().type == "application/json":
                resp = json.load(e)
                if "error" in resp:
                    print resp["error"]
        sys.exit(1)

def _send_email(requester_name, full_name, user_email, user_login, user_password,
                referent_name, referent_email, admin,
                instance, server, template_message, template_subject):

    if admin:
        help_info = HELP_INFO_REFERENT
    elif referent_name:
        help_info = HELP_INFO_OTHER.format(**{'referent_name': referent_name, 'referent_email': referent_email })
    else:
        help_info = ''

    message = template_message.format(**{
        'full_name': full_name,
        'instance': instance,
        'server': server,
        'user_login': user_login,
        'user_password': user_password,
        'requester_name': requester_name,
        'help_info': help_info,
        })
    subject = template_subject.format(**{
        'instance': instance
    })

    msg = MIMEText(message, "plain", "utf8")
    msg['Subject'] = subject
    msg['From'] = EMAIL_SETTINGS['from_addr']
    msg['To'] = user_email

    if False: # not EMAIL_SETTINGS['requireTransportSecurity']: # TODO: not working ?
        from smtplib import SMTP_SSL as SMTP       # this invokes the secure SMTP protocol (port 465, uses SSL)
    else:
        from smtplib import SMTP                  # use this for standard SMTP protocol   (port 25, no encryption)


    conn = SMTP(EMAIL_SETTINGS['smtphost'], port=EMAIL_SETTINGS['port'])
    # TODO 'port': 587,
    conn.set_debuglevel(False)
    conn.login(EMAIL_SETTINGS['username'], EMAIL_SETTINGS['password'])
    try:
        conn.sendmail(EMAIL_SETTINGS['from_addr'], [user_email], msg.as_string())
        print("Registration mail sent to %s" % user_email )
    except Exception, exc:
        print("Registration mail failed: %s" % str(exc) )
    finally:
        conn.quit()

# TODO: send password via SMS ("Votre mot de passe vous a été envoyé par SMS au numéro: ")
def later():
    params = {
        'src' : '1111111111', # Sender's phone number with country code
        'dst' : user_phone, # Receiver's phone Number with country code
        'text' : u"Le mdp watcha est: " + new_pass, # Your SMS Text Message - French
        #    'url' : "http://example.com/report/", # The URL to which with the status of the message is sent
        'method' : 'POST' # The method used to call the url
    }

    # FIXME comment for now to avoid to waste SMS fees
    response = self.sms.send_message(params)
    # FIXME handle error:
    #if response[0] != 202:

    # FIXME allow to send again mail/SMS...
    # Success


VERSION = "0.6"
CONFIG_TEMPLATE=u'''# -*- coding: utf-8 -*-

# Version of this file, do not modify
VERSION = "{version}"


SERVER = "https://url.to.the.server"
CORE = "https://url.to.the.core.server"

# Name of the person or institution who sends the email
ADMIN=""

# The name of the Watcha instance. Usually the customer's name (e.g. company name)
INSTANCE=""

# new users to create
USERS = [
    # [u'full name', 'email@adress', 'username']
]

# users to send a new password to
RESET_PASSWORD_FOR_USERS = [
  # '@username:server_name' # server_name from homeserver.yaml
]

# optional
REFERENT_USERNAME='a user_name listed in NEW_USERS'

SHARED_SECRET='registration_shared_secret from homeserver.yaml'

'''.format(version=VERSION)

def main():
    from os.path import basename, dirname, exists, splitext, abspath
    import sys

    if len(sys.argv) < 2:
        print 'Usage: register_watcha_users <user configuration file>.py'
        return
    config_file = abspath(sys.argv[1])
    if not config_file.endswith('.py'):
        print "Config file name must finish with .py"
        return

    if not exists(config_file):
        with open(config_file, 'w') as f:
            f.write(CONFIG_TEMPLATE)
        print "Template user configuration file created at %s. Please fill it now and re-run" % config_file
        return

    # the loading of the config file, is **ugly**... but I don't find easier ways...
    mylocals = {}
    execfile(join(dirname(__file__), 'register_new_matrix_user'), {'__name__': None}, mylocals)
    mylocals['__name__'] = None
    execfile(join(dirname(__file__), 'register_new_matrix_user'), mylocals, mylocals)

    sys.path.append(dirname(config_file))
    try:
        config = __import__(splitext(basename(config_file))[0], ['NEW_USERS', 'SERVER', 'CORE', 'ADMIN', 'INSTANCE',
                                                                 'SHARED_SECRET', 'REFERENT_USERNAME', 'VERSION', 'RESET_PASSWORD_FOR_USERS'])
    except ImportError, e:
        print "Could not import users from file %s. Is it a valid file ?" % config_file
        return

    if not hasattr(config, 'VERSION') or config.VERSION != VERSION:
        print "Config file version ({config_version}) incompatible with this version ({script_version}) of the script. Maybe pull an older version of the script ?".format(config_version=(config.VERSION if hasattr(config, 'VERSION') else 'none found'), script_version=VERSION)
        return

    if not config.NEW_USERS and not config.RESET_PASSWORD_FOR_USERS:
        print "No user found in %s, please edit file and add users" % config_file
        return
    if not hasattr(config, 'SHARED_SECRET') or not config.SHARED_SECRET:
        print "No shared secret in %s, please edit file and add users" % config_file
        return

    if hasattr(config, 'REFERENT_USERNAME'):
        referents = [user for user in config.NEW_USERS if config.REFERENT_USERNAME == user[2]]
        if not referents:
            print "Referent user name not found in list of users"
            return

        referent = referents[0]
        referent_name, referent_email, referent_username = referent
    else:
        referent_name, referent_email, referent_username = None, None, None

    print "User creation commands to run on the server:"
    print
    for user in config.NEW_USERS:
        full_name, email, user_name = user
        password = generate_password()
        admin = referent_username == user_name

        _request_registration('register',
                              user_name, password, config.CORE, config.SHARED_SECRET, admin)
        try:
            client = MatrixClient(config.CORE)
            token = client.login_with_password(username=user_name, password=password)
            user = client.get_user(client.user_id)
            user.set_display_name(full_name)
            print 'Display name:', user.get_display_name()
        except Exception, e:
            print "FAILED to set display name, sending email anyway..."
            print e

        _send_email(config.ADMIN, full_name, email, user_name, password,
                    referent_name, referent_email, admin,
                    config.INSTANCE, config.SERVER,
                    CONFIRMATION_EMAIL_MESSAGE_FR,
                    CONFIRMATION_EMAIL_SUBJECT_FR)

    for user_id in config.RESET_PASSWORD_FOR_USERS:
        password = generate_password()

        user_name = get_localpart_from_id(user_id)
        print "user_id", user_id
        print "user_name", user_name

        _request_registration('reset_password', user_id,
                              password, config.CORE, config.SHARED_SECRET, False)
        admin = referent_username == user_name

        # checks that the new password works, and get the user's full name.
        try:
            client = MatrixClient(config.CORE)
            token = client.login_with_password(username=user_name, password=password)
            user = client.get_user(client.user_id)
            full_name = user.get_display_name()
        except Exception, e:
            print "FAILED to log in with new password, not sending email !!..."
            print e
            continue

        _send_email(config.ADMIN, full_name, email, user_name, password,
                    referent_name, referent_email, admin,
                    config.INSTANCE, config.SERVER,
                    PASSWORD_EMAIL_MESSAGE_FR,
                    PASSWORD_EMAIL_SUBJECT_FR)

if __name__ == "__main__":
    main()
